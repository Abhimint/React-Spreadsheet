{"version":3,"sources":["logo.svg","cell/Cell.js","sheet/Sheet.js","withCellIdentifyingLayout.js","common/utils/ArithmeticFunctions.js","formula-bar/FormulaBar.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Cell","props","state","readOnly","reaTimeCellInput","thisCell","React","createRef","this","setState","console","warn","current","activeElement","type","className","id","ref","onFocus","stateWhenFocused","bind","onDoubleClick","enableForAddingValue","Component","SheetClass","WrappedComponent","withCellIdentifyingLayout","rowsToRender","rows","push","toString","colsToRender","cols","strings","alphabetList","length","style","display","gridColumnStart","gridColumnEnd","gridRow","getActiveCell","event","activeCellChangeCallback","target","currentActiveCell","firstCell","ReactDOM","findDOMNode","childNodes","focus","inputForActiveCell","cellsToRender","onClick","getCellNumericValue","cellID","document","getElementById","value","FormulaBar","changeEvent","test","charAt","realTimeFormulaInput","numericVal","preventDefault","children","onSubmit","afterSubmit","formulaLabel","placeholder","formulaPlaceholder","onChange","handleChange","App","handleClick","activeCell","formulaBarRealTimeInput","cellInput","src","logo","alt","href","rel","Boolean","window","location","hostname","match","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.968b2495.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React from 'react';\nimport './Cell.css';\nimport PropTypes from 'prop-types'\n// import { RealTimeCellInput } from './../App';\n// import CellContext from './../context-provider/CellContext';\n\n/*\nGoals\n    - #1: get the cells to have default behaviour of disabled -- done\n    - #2: on double mouseDown callback change input from being disabled to be abled -- done\n    - #3: design how you can get the value of the cell to be updatable once it is modified by the \n    formula component \n    - #4: check how to enable the direction key capability on every input cell\n        - using focus on the cell as a state in on the cell level itself that is updated via prop\n        - might then have to control this using an HOC \n    - #5: add a onkeypress event handler that updates the 'readonly' state to false \n    and allows you to type\n    - #6: * optional * on hover of the cell, display its id \n*/\n\nexport default class Cell extends React.Component{\n    constructor(props){\n        super(props);\n        this.state = {\n            readOnly: true,\n            reaTimeCellInput: ''\n        };\n        this.thisCell = React.createRef();\n    }\n\n    enableForAddingValue() {\n        this.setState({readOnly: !this.state.readOnly})\n        console.warn(\"doubleclick fired\");\n    }\n\n    stateWhenFocused() {\n        const node = this.thisCell.current;\n        node.activeElement ? this.setState({readOnly: false}) : this.setState({readOnly: true});\n    }\n\n    render() {\n        return (\n            // <cellContentContext.Consumer>\n            // <CellContext.Consumer>\n                <input \n                    type=\"text\"\n                    className=\"base-cell\"\n                    id={this.props.id}\n                    ref={this.thisCell}\n                    // disabled={(this.state.disabled) ? \"disabled\" : \"\"}\n                    readOnly={this.state.readOnly}\n                    onFocus={this.stateWhenFocused.bind(this)}\n                    onDoubleClick={this.enableForAddingValue.bind(this)}\n                    // onChange={this.props.handleChange}\n                    // value={this.context}\n                >\n                </input>\n            // </CellContext.Consumer>\n            //</cellContentContext.Consumer> \n        );\n    }\n}\n\nCell.propTypes = {\n    id: PropTypes.string.isRequired\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './Sheet.css';\n\nimport Cell from './../cell/Cell';\nimport strings from \"./../Strings.json\";\nimport withCellIdentifyingLayout from '../withCellIdentifyingLayout';\n\n/*\nGoals\n    - #1: get the Sheet component to display a series of static cells in one row\n    for a fixed width  -- done\n    - #2: add multiple rows to copy the same  -- done\n    - #3: keep focus still active on cell if next activeElement is FormulaBar  -- * optional *\n    - #4: maybe create a 'focus stack'? that keeps a track of which cell was last in focus before \n    user moved onto the formula bar?\n        - use state to check which cell is in focus and feed that as a prop on the sheet level -- done\n            - Had to use a callback prop to do this. States cannot be used to mutate the prop of the same component\n*/ \n\n/*\nThoughts\n    - Choosing \"grid\" layout over \"table\" layout to make it easier to get set up \n    with dynamic positioning and tagging of elements\n        - furthermore, it is much more easier to extend the grid for a \"dynamic spreadsheet\"\n        and is a more robust, new api in this context compared to table\n*/\n\nclass Sheet extends React.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            reaTimeCellInput: '',\n            currentActiveCell: null\n        }\n    }\n\n    componentDidMount() {\n        const firstCell = ReactDOM.findDOMNode(this).childNodes[0];\n        firstCell.focus();\n        // Temp. For accuracy when the first cell by default is 'A0'. Shift this callback later \n        // into a state or some default const on app init\n        const {activeCellChangeCallback} = this.props;\n        activeCellChangeCallback(firstCell.id);\n    }\n\n    componentDidUpdate() {\n        console.warn(\"From app to sheet: input for focused cell - \", this.props.inputForActiveCell);\n        // declaring setState here on load will break; too many cells to display\n        // this.setState({reaTimeCellInput: this.props.inputForActiveCell});\n        // const currentActiveCell = this.state.currentActiveCell;\n        // currentActiveCell.value = this.props.inputForActiveCell;\n        // console.warn(\"Ran handleChange in Sheet. Current active cell\", currentActiveCell);\n    }\n\n    getActiveCell = (event) => {\n        const {activeCellChangeCallback} = this.props;\n        activeCellChangeCallback(event.target.id);\n\n        this.setState({currentActiveCell: event.target});\n    }\n\n    render() {\n        // console.warn(strings.alphabetList.length);\n        const rowsToRender = [];\n        for (let rows = 0; rows <= 30; rows++){\n            rowsToRender.push(<div>{rows.toString}</div>+\"\\n\");\n        }\n\n        const cellsToRender = [];\n        for (let rows = 0; rows <= 30; rows++){\n            for (let cols = 0; cols <= strings.alphabetList.length - 1; cols++){\n                cellsToRender.push(<Cell id={strings.alphabetList[cols]+rows.toString()}></Cell>);\n            }\n        }\n        return (\n            // <CellIdentifier>\n                <div \n                    className=\"sheet\"\n                    onClick={(event) => this.getActiveCell(event)}\n                    // inputForActiveCell={this.props.inputForActiveCell}\n                >\n                        {cellsToRender}\n                </div>\n            // </CellIdentifier>\n        );\n    }\n}\n\nconst SheetClass = withCellIdentifyingLayout(Sheet);\n\nexport default SheetClass;","import React from 'react';\nimport strings from './Strings.json';\nimport './cell/Cell.css';\n\nconst withCellIdentifyingLayout = (WrappedComponent) => {\n    class withCellIdentifyingLayout extends React.Component {\n        \n        render() {\n            const rowsToRender = [];\n            for (let rows = 0; rows <= 30; rows++){\n                rowsToRender.push(<div className=\"row-numbering\">{rows.toString()}</div>);\n            }\n            const colsToRender = [];\n            for (let cols = 0; cols <= strings.alphabetList.length -1; cols++){\n                colsToRender.push(<div className=\"col-alphabetized\">{strings.alphabetList[cols]}</div>);\n            }\n            return(\n                <div className=\"layout-hoc\" style={{display: \"grid\"}}>\n                    <div className=\"col-alphabetized-container\" style={{display: \"inline-flex\"}}>{colsToRender}</div>\n                    <div style={{gridColumnStart: \"1\", gridColumnEnd: \"2\", gridRow: \"2/31\"}}>{rowsToRender}</div>\n                    <div style={{gridColumnStart: \"2\", gridColumnEnd: \"27\", gridRow: \"2/31\"}}><WrappedComponent {...this.props} /></div>\n                </div>\n            );\n        }\n    }\n    return withCellIdentifyingLayout;\n}\nexport default withCellIdentifyingLayout;","// update this to accomodate infinite # of params\nexport const addOrSubtract = (operandA, operandB, operation) => {\n    return (operation === \"+\") ? (operandA + operandB) : (operandA - operandB)\n}\n\nexport const getCellNumericValue = (cellID) => {\n    if (!!document.getElementById(cellID)){\n        return +(document.getElementById(cellID).value);\n    } else {\n        return;\n    }\n}\n\n// update this to only give the list of the operators in the end\n// export const inputValueStringStrip = (inputExpression) => {\n//     const operandA, operandB, operation;\n//     inputExpression.trim();\n//     const operandArr = inputExpression.split('{opera}')\n//     switch (key) {\n//         case value:\n            \n//             break;\n    \n//         default:\n//             break;\n//     }\n// }\n\n// export const parseAdditionSeparatedExpression = (expression) => {\n//     const numbersString = expression.split('+');\n//     const numbers = numbersString.map((arrElement) => +arrElement);\n// }\n\nexport default getCellNumericValue;","import React from 'react';\nimport './FormulaBar.css';\nimport strings from './../Strings.json'\n// import cellContentContext from './../context-provider/ContextProvider'\nimport { getCellNumericValue } from './../common/utils/ArithmeticFunctions';\n\n/*\nGoals \n    - #1: 2-way/bi-directional bind content between selected input and formula  -- * optional *\n        - with more time, this is best to be set up using redux for scalability\n    - #2: set the position to be sticky to the window on horizontal scroll\n    - #3: update formula bar by adding it as a form with a submit for \n    executing some operations on submit - done\n        - a: form should be able to add two number in the form\n            - input should have onChange function that checks if two numbers are present \n    - #4: align form into grid \n*/\n/*\nThoughts\n    - Upon checking other existing libraries like 'react-datasheet', turns out that none of them \n    have a 'Formula Bar' like mine. Maybe it is because they realized React \n    is unable to do 2-way binding\n    - Upon extending the functionality of the operands, the regex will need to be updated\n    - Main goal is STILL to get the result from the formula to be displayed in the last focused cell\n    - This exercise is REALLY good for string manipulation in js\n*/\n\nexport default class FormulaBar extends React.Component {\n    constructor(props){\n        super(props);\n        this.state = {}\n    }\n\n    //TODO: Build an \"allowed\" and \"not allowed\" mode\n    /* 3 part process\n        - regex to sanitize exactly what is added into the formula\n        - string stripping to get + or - from the string and also save the two operands\n            - this is also where the condition needs to be that checks if anyone of the operand is\n            a cell id\n        - function to convert stripped operands into \n            - a number or\n            - reference the value from the cell id provided\n        and then pass them to another function that accepts the operands, and a param to check what\n        kind of a operation it is and then based on a switch case, add or subtract\n\n        -- trying to get the flow to always be\n            - write something in a cell first\n            - only evaluation should be done in the formula bar\n                - for this, always have the '=' sign prefilled by default (onActive)\n    */\n    handleChange(changeEvent) {\n        // #1 - Sanitize input to conform to the requirements  \n        let allowedOperandsPattern = /[\\s?\\d+^\\w+\\s?]/\n        console.warn(allowedOperandsPattern.test(changeEvent.target.value));\n        if(changeEvent.target.value.charAt(0) === \"=\") {\n            console.warn(changeEvent.target.value);\n        }\n\n        // #2 - Send Formula input back to parent as callback\n        const {realTimeFormulaInput} = this.props;\n        realTimeFormulaInput(changeEvent.target.value);\n\n        const numericVal = getCellNumericValue(changeEvent);\n        console.warn(\"Numeric value function testing\", numericVal);\n\n        // reference to current cell that the formula should write to\n        // console.warn(\"Current cell to write to\", this.props.activeCellToWriteTo);\n    }\n\n    afterSubmit(event) {\n        event.preventDefault();\n        // event.target.children[1].value <-- value of the input on submit\n        let allowedOperandStructure = /\\w\\d\\d?/;\n        allowedOperandStructure.test(event.target.children[1].value) ?\n            console.warn(\"Input operand structure is correct\") :\n            console.warn(\"Input operand structure is incorrect so please rectify\");\n    }\n\n    render() {\n        return(\n            <form className=\"form\" onSubmit={(event) => this.afterSubmit(event)}>\n                <label className=\"formLabel\">\n                    {strings.formulaLabel}\n                </label>\n                <input\n                    className=\"formula\"\n                    placeholder={strings.formulaPlaceholder}\n                    onChange={(event) => this.handleChange(event)}\n                    // value={this.props.inputValue}\n                >\n                </input>\n            </form>\n        );\n        \n    }\n}","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport Cell from './cell/Cell';\nimport Sheet from './sheet/Sheet';\nimport FormulaBar from './formula-bar/FormulaBar';\n// import CellProvider from './context-provider/CellProvider';\n\nclass App extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {\n      activeCell: '',\n      cellInput: ''\n    }\n  }\n\n  handleClick = (currentActiveCell) => {\n    // state at this point will only produce \"pending state\" which is always a step behind\n    // cannot use it in the same function. Let the cycle of the state update complete before using \n    // it elsewhere\n    this.setState({activeCell: currentActiveCell});\n    console.warn('Currently Active cell is', currentActiveCell);\n  }\n\n  handleChange = (formulaBarRealTimeInput) => {\n    // updating the state and writing it to the cell. Not the best implementation as this\n    // should have been done using Redux best or atleast via context api or props sent down\n    const activeCell = document.getElementById(this.state.activeCell);\n    this.setState({cellInput: formulaBarRealTimeInput}, () => {\n      activeCell.value = this.state.cellInput;\n    });\n  }\n\n  render() {\n    return (\n      // <CellProvider value={this.state.cellInput}> \n        <div className=\"App\">\n          <header className=\"App-header\">\n            <img src={logo} className=\"App-logo\" alt=\"logo\" />\n            <p>\n              Edit <code>src/App.js</code> and save to reload.\n            </p>\n            <a\n              className=\"App-link\"\n              href=\"https://reactjs.org\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              Learn React\n            </a>\n              <Cell id=\"firstCell\" />\n              <FormulaBar\n                // activeCellToWriteTo={this.state.activeCell}\n                realTimeFormulaInput={this.handleChange.bind(this)}\n              />\n              <Sheet \n                activeCellChangeCallback={this.handleClick.bind(this)}\n                inputForActiveCell={this.state.cellInput}\n              />\n          </header>\n      </div>\n      // </CellProvider>\n      \n    );\n  }\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}